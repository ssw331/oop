#include<iostream>
#include"oop_doc.h"
using namespace std;

class Point;//前向声明，没有类体，无法实例化，可以引用或当指针
class what;

class haha
{
	friend what;
	//this: 每个成员函数的隐式形参，是一个对象指针
	//每次编译都会对成员函数进行重写
	//所以实际上每次调用的时候都会把对象的地址传参给this
	//需要返回对象自身的函数可以返回*this
	//如果成员名和形参名相同时也可以用this指针来区分
	//如果成员函数是const常函数，那么重写时this形参会变成const 类名 *const this，成为指向常对象的常指针
private:
	int test;//禁止在类声明时对成员变量初始化
	char* str;
	static int wh;
protected:
	int inher;
public:
	int so;
	haha()//构造函数--》没有参数的构造函数即默认构造函数
	//没有任何构造函数的定义时编译器会自动定义合成默认构造函数
	//无论复制构造还是其他构造，只能在定义对象时调用，而且只调用一个，这很重要
	{
		test = -1;//主要目的：初始化对象中的私有/保护成员
	}
	haha(int in, int out = -1)//构造函数重载
	{
		test = in;
	}
	haha(int why, int so) :test(1)//构造函数的初始化列表（:之后的玩意儿）
		//如果没有初始化列表，同时没有默认构造函数，那么系统会报错
		//因为没有初始化列表的话，系统会调用默认构造函数
		//初始化列表不在声明中指明，而是在定义中指明
		//即构造函数在体外定义时才指明初始化列表
		//初始化列表中每个成员只能被指定一次
		//实际的初始化顺序和列表的顺序无关，和成员在类中的定义顺序绑定
		//避免用成员初始化成员
		//一般初始化（不用对象初始化对象）都会调用构造函数，无论是 对象名(参数)，还是 对象名=参数
	{
		cout << test;
	}
	haha(const haha& r) :test(r.test)//复制构造函数
		//有且只有一个参数：本类类型的对象引用
		//赋值：对已有对象赋予值
		//复制：生成一个和已有对象相同的原本不存在的对象
		//每个类必须有一个复制构造函数
		//如果没有定义，那么系统会生成一个合成复制构造函数，会逐个成员初始化（针对非静态成员）
		//在函数传参和返回对象、一般的用对象初始化对象、*用元素初始化列表初始化数组元素*时
		//浅复制：没有对数据的动态内存部分进行复制，而仅仅复制了一个指针
		//		浅复制的问题，一旦源本被撤销，那么副本会丢失数据
		//深复制：动态内存部分也复制了
		//合成复制构造函数一般是浅复制
	{
		test = r.test;
		str = new char[test];
		if (str != 0)
			strcpy(str, r.str);
		//以上为深复制
		str = r.str;
		//以上为浅复制
	}
	void helloworld(int, const haha&);
	haha& x();//不要返回局部对象的指针或引用，会导致迷向指针
	haha* y();
	~haha()//析构函数，销毁对象用，有且仅有一个，不可重载，在对象离开作用域后系统会自动调用
		//编译器总会生成一个合成析构函数，不论有没有定义析构函数
		//合成析构函数只删除指针，分配的内存空间是不会被合成析构函数回收的
		//如果类需要析构函数，那么几乎一定要定义复制构造函数和赋值运算符重载，又称析构函数三法则
		//合成析构函数是没有delete指令的
	{

	}
	//析构和构造的调用次序：先构造的后析构，后构造的先析构。
};

//构造函数的无参数调用:
haha 你;
//构造函数的有参数调用:
haha 我(0);

//构造函数在定义对象时自动调用，其余生命期无法主动调用
//这玩意儿一般是公有的，毕竟私有了你也没法在类外初始化对象了
/*
* 对于构造函数，一般不提倡在里面干初始化之外的事
* 构造函数应当对每个成员函数进行初始化
* 构造函数一次用一种
* 还是那句话，构造函数依然是函数。默认参数也是可以加入的
* 但同样的，一旦出现重载和默认参数的参数列表有冲突（二义性出现），调用会出问题
* 默认参数只能在类内指定（其实就是必须在声明时指定）
* 
* 类有且仅有一个默认构造函数，当类内没有默认构造函数的定义的时候，编译器会自动定义一个默认构造函数（空函数）
*/

class Point
{
public:
	int x,y;
	Point(const string& obj);
	//构造函数隐式转换实现：
    // 类名(const 指定数据类型& obj)
    // 可以在类内对构造函数用explicit关键字来禁止构造函数的隐式转换
}p{ 10,10 };//如果类本身的成员函数都是公共的，那么可以用大括号直接初始化

void haha::helloworld(int a,const haha& b)//如果不希望引用/指针的内容被改写，const关键词可以防止在函数体内改写数据
{
	return;
}

//类的作用域：
//即类定义时的类体内，注意:即使有同成员列表的类，名字不同时是完全不同的作用域
//类作用域外只能用对象、指针或引用的方式来访问成员
//静态成员和类中类型成员需要用类作用域运算符访问（::）

//作用域运算符视为类作用域的延伸
/*
* 类成员声明中的名字查找：
*	1. 检查出现在名字使用之前的声明
*	2. 如果1查找失败，则查找包含类作用域中的声明和出现在类定义
*	   之前的声明
* 类成员定义中的名字查找：
*	1. 检查成员函数局部作用域中的声明
*	2. 如果1失败，则检查所有类成员的声明
*	3. 如果2失败，则检查在此类定义之前的作用域中的声明
*/

class T//外围类
{
public:
	int z;
private:
	int y;
	static int m;
	enum alpha { A, B, C, D };
	class Q
	{
		alpha A;
		int x;
		Q()
		{
			x = m;
			x = y;
			x = z;
		}
		//嵌套类
		/*
		* 嵌套类是独立的类
		* 与外围类相互独立（对象也是），且只在外围类的作用域中可见其名字
		* 即不会在其他作用域中发货所能名冲突
		* 完全独立的类，可以按照一般类来理解其定义方式
		* 外围类的对象不包括嵌套类，反之亦然
		* 嵌套类可以直接引用外围类的静态成员、类型名和枚举成员
		* 外围类作用域之外的成员引用则需要作用域运算符
		*/
	};
};

int w = 1;

void none()
{
	int x = 10;
	static int z = 10;
	class P
	{
		int y;
		P()
		{
			y = w;
			y = z;
			y = x;//出错
		}
		//局部类
		/*
		* 所有成员必须定义在类体内
		* 只能访问外围的作用域中定义的类型名、静态变量和枚举成员
		* 函数中的动态变量无法使用，包括参数
		*/
	};
}

//按照生命期的分类：
/*
* 1. 局部对象：仅存在于函数体内，函数结束则自动释放
* 2. 静态局部对象：作用域仅限函数体内，但生命期自第一次定义开始到程序结束被释放
* 3. 全局对象：程序开始到程序结束被释放
* 4. 自由存储对象：由new开始，由delete结束(没有delete的话即使运行结束也是不会释放的）
*/

//释放均是通过析构函数释放

//const 限定： 将函数/变量限定为只读
const haha A;
haha const B;
const int C;
//常引用
const haha& b;
//指向常变量的指针
const int* p;
//常指针
int const* q;
class what
{
private:
	int t;
public:
	int a;
	friend haha;
	//友元――类
	friend void haha::helloworld(int a, const haha& h);
	friend void none();
	//友元――函数
	//声明后该函数/类可以使用声明友元的类内的私有成员
	/*
	* 友元是单向的，在哪个类内声明，在哪个类内可以使用友元类/函数，反之不行
	* 友元不能继承
	*/
	int fun() const//表示常成员函数-->内部对于成员的修改都会被拒绝
	{
		return 1;
	}
	const int fun1()//表示返回常量的函数
	{
		haha k;
		k.test;//这个是haha类的友元声明的作用
		return 1;
	}
};
//静态数据成员
/*
* 使用前必须初始化
* 初始化有且仅有一次，不会受到public/private/protected限制
* 初始化时无须静态关键字，但需要类作用域运算符
* 可以作为成员函数的默认参数
* e.g.   void func(int i = _static_int)
* 可以被定义为所在类的对象
*/
//静态成员函数
/*
* 只能访问静态成员（包括变量和函数）
* 由于静态成员函数不会隐式创建this指针，所以可以不定义对象而直接调用静态成员函数
*/


/*
* 继承与派生：
* 继承――即从父类（基类）角度，创建一个新的子类（派生类)，其中保留了基类的成员
* 派生――即子类（派生类）在继承的基础上，增加或改变了成员
* 
* 派生分类;
*	单级派生：只有两层
*	多级派生：多层
* 
* 多重继承：同一派生类有两个以上的基类
* 
* 派生类----->基类  :  抽象
* 基类----->派生类  :  特例化
* 
*/

class world : public haha, public what
	//以上是派生类的声明
	//格式： class 派生类名 : 访问标号 基类名1, 访问标号 基类名2...
	//基类必须已声明（和友元一样）
	//访问标号决定了该派生类对继承的成员的访问权限设置(public,protect,private)
	// public：保留基类成员原本的访问权限
	// protected：保留基类私有成员的访问权限（仍是基类私有），但将protected和public权限改为protected
	// private：将基类所有成员改为派生类私有（基类中的私有还是基类私有）
	// 
	// 即  无论如何，基类私有的成员一直都无法被除基类以外的任何类或用户访问，除非对其进行同名更新（但其实也是定义了一个新的成员）
	// 
	//友元、基类的构造和析构不继承
	//因此需要为派生类写新的构造和析构
	//基类的成员的访问权限会原模原样地继承下来，只有同名覆盖才能修改<因此只存在一个实例的静态成员就无法被修改权限>
	//也可以按需增加成员
{
private:
	char* str;//此处更新了str
	static int wh;
public:
	world():haha(), what(),str(NULL),test(-1)//派生类自身的构造函数    
		//格式：派生类名（形参列表）: 基类名（基类初始化实参）<这里是类的构造函数的调用声明，不是对象的，编译时会根据这里的参数量来调用对应的基类构造函数>...,派生类成员的初始化列表<这里面可以有对象,但不能有基类的成员> 
		// {函数体}
		//派生类构造函数的执行顺序：基类构造函数<按照声明次序调用>-》派生类初始化列表<按照声明次序调用>-》派生类构造列表的函数体
		//类似这里实例化的构造函数中的无参数初始化（即有默认构造函数）的基类，可以把它的初始化隐式化[构造函数会默认调用默认构造函数]
		//派生类的合成默认构造函数会调用基类的默认构造函数。
	{
		//而且基类中的private在派生类内也无法访问
		//更新后str可访问
		inher = -1;//protected可以被派生类访问
		cout << "it is null." << endl;
	}
	void helloworld()//派生类可以定义和基类成员相同的函数，会覆盖基类的同名函数，同时不会改写基类的对应函数<相当于重载+下一行的陈述>
		//但派生类调用同名函数时会调用派生类体中声明的函数
		//那么如何调用基类的同名函数/其他成员函数/数据成员呢？
		//――派生对象.基类名::基类函数名
		//这样可以保证调用的对象

		//当然，由于派生本身相当于在基类的类体中补充、增加了成员
		//所以可以利用重载来调用基类的同名函数/其他成员函数
	{
		return;
	}
	int test;//数据成员同理
	//对于静态成员，无论继承有多大，静态成员永远只有一个实例<权限可更新>
	~world()//派生类析构函数
		//执行顺序：派生类析构函数（删除新增）-》子对象的析构函数<按照声明次序的逆序调用>-》基类析构函数<按照声明次序的逆序调用>
		//子对象和基类的析构函数会在调用派生类析构函数时由系统自动调用
	{
		cout << "there is nothing." << endl;
	}
protected://对于继承和派生，有时需要派生类访问不被用户访问的成员，此时需要将其定义在protected下
	//这样的话派生类被允许访问，但外部用户仍不可访问
	//而且强调了private只有当前类和友元可以访问，派生类和用户均不可访问
};

class O : public Point;//这个是错误的，派生类的前向声明只要声明类名即可
class OP;

int main()
{
	haha A, B;
	const haha* const th = &A;
	haha list[2] = { haha(6), haha(6) };//可以用这种方式定义对象数组
	haha why[3] = { 2,3,4 };//这里是将{}内的值作为实参分别传给具有单个形参（不包括默认参数）的构造函数进行对象初始化。
	//构造函数的调用次序是按照数组序号从小到大，析构相反
	//没有初始化就会开始调用默认构造函数
	haha* p = &A;
	p->helloworld(1, B);
	int* q = &A.so;//可以指向非私有成员，不可指向私有成员
	int haha::*w = &haha::so;//数据成员指针：数据成员类型 类名::*指针变量名=成员地址初值;
	A = B;//只会对非静态成员变量进行赋值。
	//上语句只对同类对象变量成立
	void (haha:: * f)(int a, const haha& b) = &haha::helloworld;
	//成员函数指针：
	//返回类型 (类名::*指针变量名)(形式参数列表) <const> =成员函数地址初值
	//const对于 常函数 是需要的，一般函数不加
	//常函数： 返回类型 函数名(形参列表) const{函数体};

	//typedef char (Data::*GETFUNC)(Data::index,Data::index) const;
	//可以用这种方式使用类型别名，简化语句

	//类成员指针的使用：
	(A.*f)(1, B);
	p->*w;
	p = new haha;//Caution：这里为对象动态分配空间后 **不会** 随着程序结束而自动销毁
	world C;
	C.haha::so;
	C.helloworld();
	//赋值兼容：需要基类对象的位置，可以用公有派生类（即访问标签为public）的对象类替代
	//以下为赋值兼容的场景：
	B = C;
	B.helloworld(1, C);//派生类对象对基类对象赋值
	haha& D = C;//派生类对象初始化基类对象
	haha* E;
	E = &C;//派生类对象的地址可以赋值给基类对象
	//以上为赋值兼容的几个场景（可以扩展到函数的传参上）
	//赋值兼容是多态性的重要基础
	delete p;//必须手动delete
}